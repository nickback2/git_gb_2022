# Репозиторий для тренировки

Делаем себе fork, вносим изменения и присылаем Pull request.

## Основы Git

Основы Git - Запись изменений в репозиторий
Запись изменений в репозиторий
Итак, у вас имеется настоящий Git-репозиторий и рабочая копия файлов для выбора проекта. Вам нужно делать некоторые изменения и фиксировать «снимки» состояния (моментальные снимки)

Помните, что каждый файл в следующем рабочем каталоге может находиться в одном из двух блоков: под версионным контролем (отслеживаемые) и нет (неотслеживаемые). Отслеживаемые файлы — это те файлы, которые были в последней снимке состояния проекта; они могут быть неизменёнными, изменёнными или подготовленными к комиссии. Если кратко, то отслеживаемые файлы — это те файлы, о которых знает Git.

Неотслеживаемые файлы — это всё остальное, любые файлы в следующем рабочем каталоге, которые не входили в ваш последний снимок состояния и не готовились к комиссии. Когда вы впервые клонируете репозиторий, все файлы будут отслеживаемыми и неизменёнными, потому что Git только что их извлекли и вы ничего пока не редактировали.

Как только вы отредактируете файлы, Git изменяет их как изменённые, так как вы изменили их с момента последнего коммита. Вы индексируете эти изменения, фиксируете все проиндексированные изменения, затем цикл повторяется.

![цикл](/cikl.jpg)



# Основные команды Git

 Введение в контроль версий. Работа с Git. Составление инструкции по работе с Gi   
 
    ✦ git init – инициализация локального репозитория
    ✦ git status – получить информацию от git о его текущем состоянии
    ✦ git add – добавить файл или файлы к следующему коммиту
    ✦ git commit -m “message” – создание коммита.
    ✦ git log – вывод на экран истории всех коммитов с их хеш-кодами
    ✦ git checkout – переход от одного коммита к другому
    ✦ git checkout master – вернуться к актуальному состоянию и продолжить работу
    ✦ git diff – увидеть разницу между текущим файлом и закоммиченным файлом
    ✦ git branch – посмотреть список веток в репозитории
    ✦ git branch <название ветки> – создать новую ветку
    ✦ git checkout <название ветки> – переход к другой ветке
    ✦ git branch -d <название ветки> – удалить ветку
    ✦ git clone <url-адрес репозитория> – клонирование внешнего репозитория на локальный ПК
    ✦ git pull – получение изменений и слияние с локальной версией
    ✦ git push – отправляет локальную версию репозитория на внешний

# Синтаксис языка Markdown
 Введение в контроль версий. Работа с Git. Составление инструкции по работе с Git.

    ✦ # Заголовок – выделение заголовков. Количество символов “#” задаёт уровень заголовка (поддерживается 6 уровней).
    ✦ = или - – подчёркиванием этими символами (не менее 3 подряд) выделяют заголовки первого (“=”) и второго (“-”) уровней.
    ✦ ** Полужирное начертание** или __ Полужирное начертание__
    ✦ *Курсивное начертание* или _Курсивное начертание_
    ✦ ***Полужирное курсивное начертание***
    ✦ ~~Зачёркнутый текст~~
    ✦ * Строка – ненумерованные списки, символ “*” в начале строки
    ✦ 1, 2, 3 … – нумерованные списки



Одной из наиболее популярных СКВ такого типа является RCS (Revision Control System, Система контроля ревизий), которая до сих пор устанавливается на многие компьютеры. Даже в современной операционной системе Mac OS X утилита rcs устанавливается вместе с Developer Tools.

RCS была разработана в начале 1980-х годов Вальтером Тичи (Walter F. Tichy). Система позволяет хранить версии только одного файла, таким образом управлять несколькими файлами приходится вручную. Для каждого файла находящегося под контролем системы информация о версиях хранится в специальном файле с именем оригинального файла к которому в конце добавлены символы ',v'. Например для файла file.txt версии будут храниться в файле file.txt,v. Эта утилита основана на работе с наборами патчей между парами версий (патч — файл, описывающий различие между файлами). Это позволяет пересоздать любой файл на любой момент времени, последовательно накладывая патчи. Для хранения версий система использует утилиту diff.

Рассмотрим пример сессии с RCS. Когда мы хотим положить файл под контроль RCS мы используем команду ci (от check-in, регистрировать):

# $ ci file.txt
Данная команда создает файл file.txt,v и удаляет исходный файл file.txt (если не сказано этого не делать). Также эта команда запрашивает описание для всех хранимых версий. Так как исходный файл был удален системой мы должны запросить его обратно, что бы вносить изменения. Для этого мы используем команду co (от check-out, контролировать):

# $ co file.txt
Эта команда вынимает последнюю версию нашего файла из file.txt,v. Теперь мы можем отредактировать файл file.txt и после того как закончим изменения опять выполнить команду ci для того что бы сохранить новую измененную версию файла:

# $ ci file.txt
При выполнении этой команды система запросит у нас описание изменений и затем сохранит новую версию файла.

Хотя RCS соответствует минимальным требованиям к системе контроля версий она имеет следующие основные недостатки, которые также послужили стимулом для создания следующей рассматриваемой системы:

Работа только с одним файлом, каждый файл должен контролироваться отдельно;
Неудобный механизм одновременной работы нескольких пользователей с системой, хранилище просто блокируется пока заблокировавший его пользователь не разблокирует его;
От бекапов вас никто не освобождает, вы рискуете потерять всё.
Централизованные системы контроля версий
Следующей основной проблемой оказалась необходимость сотрудничать с разработчиками за другими компьютерами. Чтобы решить её, были созданы централизованные системы контроля версий (ЦСКВ). В таких системах, например CVS, Subversion и Perforce, есть центральный сервер, на котором хранятся все файлы под версионным контролем, и ряд клиентов, которые получают копии файлов из него. Много лет это было стандартом для систем контроля версий.